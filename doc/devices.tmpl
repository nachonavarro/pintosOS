            +----------------------+
            |        OS 211        |
            |  TASK 0: ALARMCLOCK  |
            |    DESIGN DOCUMENT   |
            +----------------------+
                   
---- GROUP ----

>> Fill in the names and email addresses of your group members.

Corentin Herbinet <cah214@ic.ac.uk>
William Springsteen <ws1514@ic.ac.uk>
Vinothan Shankar <vws11@ic.ac.uk>
Ignacio Navarro <in714@ic.ac.uk>

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, or notes for the
>> markers, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course staff.


               PRELIMINARY QUESTIONS
               =====================

1.

2. A call to 'strcpy()' can overflow the buffer reserved for its output string. 
In other words, the function doesn't know the length of the destination string,
so that if the string to be copied is longer than the reserved memory for 
the destination string, the string will be copied corrupting other memory 
(leading to crashes and potentially  become an exploitable system).

3.

4.

5.

6. In Pintos we would first include the stdint.h header file, create the uint64_t
int and then we would just 'printf()' the int with '%u', an unsigned decimal integer:
  uint64_t x = 0x7700000;
  printf(%u, x);

7. Esentially a lock is a subset of a semaphore where the initial value is set to 1. 
So then regarding functions, a lock has a 'lock_release()' equivalent to a 
semaphore's 'sema_up()', a 'lock_try_acquire()' equivalent to a 
semaphore's 'sema_try_down()' and a 'acquire()' equivalent to a semaphore's
'sema_down()'. Regarding data structures, a semaphore struct has a list of waiting threads, 
while a lock struct has a semaphore struct that itself has a list of waiting threads.
The extra property that locks have that semaphores do not is that only the thread that
acquires a lock, called the lock's "owner", is allowed to release it. 

8.

9.


                 DESIGN QUESTIONS
                 ================

---- DATA STRUCTURES ----

>> A1: (2 marks) 
>> Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

---- ALGORITHMS ----

>> A2: (2 marks)
>> Briefly describe what happens in a call to timer_sleep(),
>> including the actions performed by the timer interrupt handler 
>> on each timer tick.

>> A3: (2 marks)
>> What steps are taken to minimize the amount of time spent in
>> the timer interrupt handler?

---- SYNCHRONIZATION ----

>> A4: (1 mark)
>> How are race conditions avoided when multiple threads call
>> timer_sleep() simultaneously?

>> A5: (1 mark)
>> How are race conditions avoided when a timer interrupt occurs
>> during a call to timer_sleep()?

---- RATIONALE ----

>> A6: (2 marks)
>> Why did you choose this design?  In what ways is it superior to
>> another design you considered?

